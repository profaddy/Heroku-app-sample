{"ast":null,"code":"import { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nexport default class Notifier extends Component {\n  constructor(...args) {\n    super(...args);\n    this.displayed = [];\n\n    this.storeDisplayed = id => {\n      this.displayed = [...this.displayed, id];\n    };\n  }\n\n  shouldComponentUpdate({\n    notifications: newSnacks = []\n  }) {\n    const {\n      notifications: currentSnacks\n    } = this.props;\n    let notExists = false;\n\n    for (let i = 0; i < newSnacks.length; i += 1) {\n      if (notExists) continue;\n      notExists = notExists || !currentSnacks.filter(({\n        key\n      }) => newSnacks[i].key === key).length;\n    }\n\n    return notExists;\n  }\n\n  componentDidUpdate() {\n    const {\n      notifications = []\n    } = this.props;\n    notifications.forEach(notification => {\n      // Do nothing if snackbar is already displayed\n      if (this.displayed.includes(notification.key)) return; // Display snackbar using notistack\n\n      this.props.enqueueSnackbar(notification.message, notification.options); // Keep track of snackbars that we've displayed\n\n      this.storeDisplayed(notification.key); // Dispatch action to remove snackbar from redux store\n\n      this.props.removeSnackbar(notification.key);\n    });\n  }\n\n  render() {\n    return null;\n  }\n\n}\nNotifier.propTypes = {\n  notifications: PropTypes.arrayOf(PropTypes.shape({\n    key: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    message: PropTypes.string,\n    options: PropTypes.object\n  })),\n  enqueueSnackbar: PropTypes.func.isRequired,\n  removeSnackbar: PropTypes.func.isRequired\n};","map":{"version":3,"sources":["/home/adnan/Desktop/Projects/pocs/credit-debit-software/client/src/HOC/notifications/Notifier.js"],"names":["Component","PropTypes","Notifier","displayed","storeDisplayed","id","shouldComponentUpdate","notifications","newSnacks","currentSnacks","props","notExists","i","length","filter","key","componentDidUpdate","forEach","notification","includes","enqueueSnackbar","message","options","removeSnackbar","render","propTypes","arrayOf","shape","oneOfType","string","number","object","func","isRequired"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA,eAAe,MAAMC,QAAN,SAAuBF,SAAvB,CAAiC;AAAA;AAAA;AAAA,SAC5CG,SAD4C,GAChC,EADgC;;AAAA,SAgB5CC,cAhB4C,GAgB1BC,EAAD,IAAQ;AACrB,WAAKF,SAAL,GAAiB,CACb,GAAG,KAAKA,SADK,EACME,EADN,CAAjB;AAGH,KApB2C;AAAA;;AAsB5CC,EAAAA,qBAAqB,CAAC;AAAEC,IAAAA,aAAa,EAAEC,SAAS,GAAG;AAA7B,GAAD,EAAoC;AACrD,UAAM;AAAED,MAAAA,aAAa,EAAEE;AAAjB,QAAmC,KAAKC,KAA9C;AACA,QAAIC,SAAS,GAAG,KAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACK,MAA9B,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC1C,UAAID,SAAJ,EAAe;AACfA,MAAAA,SAAS,GAAGA,SAAS,IAAI,CAACF,aAAa,CAACK,MAAd,CAAqB,CAAC;AAAEC,QAAAA;AAAF,OAAD,KAAaP,SAAS,CAACI,CAAD,CAAT,CAAaG,GAAb,KAAqBA,GAAvD,EAA4DF,MAAtF;AACH;;AACD,WAAOF,SAAP;AACH;;AAEDK,EAAAA,kBAAkB,GAAG;AACjB,UAAM;AAAET,MAAAA,aAAa,GAAG;AAAlB,QAAyB,KAAKG,KAApC;AAEAH,IAAAA,aAAa,CAACU,OAAd,CAAuBC,YAAD,IAAkB;AACpC;AACA,UAAI,KAAKf,SAAL,CAAegB,QAAf,CAAwBD,YAAY,CAACH,GAArC,CAAJ,EAA+C,OAFX,CAGpC;;AACA,WAAKL,KAAL,CAAWU,eAAX,CAA2BF,YAAY,CAACG,OAAxC,EAAiDH,YAAY,CAACI,OAA9D,EAJoC,CAKpC;;AACA,WAAKlB,cAAL,CAAoBc,YAAY,CAACH,GAAjC,EANoC,CAOpC;;AACA,WAAKL,KAAL,CAAWa,cAAX,CAA0BL,YAAY,CAACH,GAAvC;AACH,KATD;AAUH;;AAEDS,EAAAA,MAAM,GAAG;AACL,WAAO,IAAP;AACH;;AAjD2C;AAA3BtB,Q,CAGVuB,S,GAAY;AACflB,EAAAA,aAAa,EAAEN,SAAS,CAACyB,OAAV,CAAkBzB,SAAS,CAAC0B,KAAV,CAAgB;AAC7CZ,IAAAA,GAAG,EAAEd,SAAS,CAAC2B,SAAV,CAAoB,CACrB3B,SAAS,CAAC4B,MADW,EAErB5B,SAAS,CAAC6B,MAFW,CAApB,CADwC;AAK7CT,IAAAA,OAAO,EAAEpB,SAAS,CAAC4B,MAL0B;AAM7CP,IAAAA,OAAO,EAAErB,SAAS,CAAC8B;AAN0B,GAAhB,CAAlB,CADA;AASfX,EAAAA,eAAe,EAAEnB,SAAS,CAAC+B,IAAV,CAAeC,UATjB;AAUfV,EAAAA,cAAc,EAAEtB,SAAS,CAAC+B,IAAV,CAAeC;AAVhB,C","sourcesContent":["import { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nexport default class Notifier extends Component {\n    displayed = [];\n\n    static propTypes = {\n        notifications: PropTypes.arrayOf(PropTypes.shape({\n            key: PropTypes.oneOfType([\n                PropTypes.string,\n                PropTypes.number\n            ]),\n            message: PropTypes.string,\n            options: PropTypes.object\n        })),\n        enqueueSnackbar: PropTypes.func.isRequired,\n        removeSnackbar: PropTypes.func.isRequired\n    }\n\n    storeDisplayed = (id) => {\n        this.displayed = [\n            ...this.displayed, id\n        ];\n    };\n\n    shouldComponentUpdate({ notifications: newSnacks = [] }) {\n        const { notifications: currentSnacks } = this.props;\n        let notExists = false;\n        for (let i = 0; i < newSnacks.length; i += 1) {\n            if (notExists) continue;\n            notExists = notExists || !currentSnacks.filter(({ key }) => newSnacks[i].key === key).length;\n        }\n        return notExists;\n    }\n\n    componentDidUpdate() {\n        const { notifications = [] } = this.props;\n\n        notifications.forEach((notification) => {\n            // Do nothing if snackbar is already displayed\n            if (this.displayed.includes(notification.key)) return;\n            // Display snackbar using notistack\n            this.props.enqueueSnackbar(notification.message, notification.options);\n            // Keep track of snackbars that we've displayed\n            this.storeDisplayed(notification.key);\n            // Dispatch action to remove snackbar from redux store\n            this.props.removeSnackbar(notification.key);\n        });\n    }\n\n    render() {\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}